# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OffsetAddrXYDockWidget
                                 A QGIS plugin
 篩選門牌，偏移坐標
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-10-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by lin
        email                : lin315307@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.utils import iface
from qgis.core import QgsExpression,QgsVectorLayer,QgsFeatureRequest
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt.QtWidgets import QProgressBar,QProgressDialog
from PyQt5.QtWidgets import *

numChi = {0:'',1:'一' ,2:'二' ,3:'三' ,4:'四' ,5:'五' ,6:'六',7:'七',8:'八',9:'九',10:'十'}
numFull = {0:'０',1:'１' ,2:'２' ,3:'３' ,4:'４' ,5:'５' ,6:'６',7:'７',8:'８',9:'９'}
zh2digit_table = {'零': 0, '一': 1, '二': 2, '兩': 2, '三': 3, '四': 4, '五': 5, '六': 6, '七': 7, '八': 8, '九': 9, '十': 10, '百': 100, '千': 1000, '〇': 0, '○': 0, '○': 0, '０': 0, '１': 1, '２': 2, '３': 3, '４': 4, '５': 5, '６': 6, '７': 7, '８': 8, '９': 9, '壹': 1, '貳': 2, '參': 3, '肆': 4, '伍': 5, '陆': 6, '柒': 7, '捌': 8, '玖': 9, '拾': 10, '佰': 100, '仟': 1000, '萬': 10000, '億': 100000000}

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'offset_addrXY_dockwidget_base.ui'))

class OffsetAddrXYDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(OffsetAddrXYDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.__fidList = []
        self.setupUi(self)
        self.btn_offsetAddrXY.clicked.connect(self.offsetAddrXY)
        self.btn_mergeOne.clicked.connect(self.mergeOne)
        self.btn_moveFeatures.clicked.connect(self.moveFeatures)
        self.str_front.textChanged.connect(self.changeText)
        self.str_behind.textChanged.connect(self.changeText)
        self.spb_addrNum.valueChanged.connect(self.changeText)
        self.btn_offsetFloor.clicked.connect(self.offsetFloorXY)
        self.btn_offsetAuto.clicked.connect(self.offsetAuto)
        self.btn_nextPile.clicked.connect(self.pileNext)
        self.btn_prePile.clicked.connect(self.pilePre)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
        
    def numToChi(self,i): #阿拉伯轉中文數字字元
        addr = ''
        if i<=10: #阿拉伯轉中文數字
            addr = numChi[i]
        elif i>10 and i<20:
            addr =numChi[10] + numChi[i%10]
        elif i>=20:
            addr = numChi[(i//10)%10] + numChi[10] + numChi[i%10]
        return addr
    
    def numToFull(self,i): #阿拉伯轉全形數字字元
        addr = ''
        while(i!=0):
            addr= chr( i%10+65296 ) + addr
            i//=10
        return addr

    def chiToNum(self,i): #中文數字轉阿拉伯數字
        # 位數遞增，由高位開始取
        digit_num = 0
        # 結果
        result = 0
        # 暫時存儲的變量
        tmp = 0
        while digit_num < len(i):
            tmp_zh = i[digit_num]
            tmp_num = zh2digit_table.get(tmp_zh, None)
            if tmp_num >= 10:
                if tmp == 0:
                    tmp = 1
                result = result + tmp_num * tmp
                tmp = 0
            elif tmp_num is not None:
                tmp = tmp * 10 + tmp_num
            digit_num += 1
        return result + tmp

    def addrDeal(self, addrCom): #門牌字串處理
        #全形數字轉阿拉伯
        for i in range(10):
            addrCom = addrCom.replace( numFull[i] , str(i) )
        #移除地址'樓''層'相關字串
        addrCom = addrCom.replace('樓','X')
        addrCom = addrCom.replace('層','X')
        while addrCom.find('X')!=-1:
            R=addrCom.find('X')
            L=R-1
            while(addrCom[L] in numChi.values() or addrCom[L].isdigit()):
                L-=1
            if addrCom[L] != '之':
               addrCom = addrCom.replace(addrCom[L+1:R+1],'')
            else:
                addrCom = addrCom.replace('X','')

        #'號'、'底'、'地下'轉為空白
        addrCom = addrCom.replace('號','')
        addrCom = addrCom.replace('底','')
        addrCom = addrCom.replace('地下室','')
        addrCom = addrCom.replace('地下','')
        #'之'中文數字轉阿拉伯
        while addrCom.find('之')!=-1:
            R = addrCom.find('之')
            addrCom = addrCom.replace('之','X',1)
            L=R-1
            if addrCom[L] in numChi.values():
                while addrCom[L] in numChi.values():
                    L-=1
                addrCom = addrCom.replace( addrCom[L+1:R] , str(self.chiToNum(addrCom[L+1:R])) , 1 )
                
            #尾巴有中文數字則轉阿拉伯  
        if addrCom[len(addrCom)-1] in numChi.values():
            R = len(addrCom)-1
            L=R-1
            while addrCom[L] in numChi.values(): L-=1
            addrCom = addrCom.replace( addrCom[L+1:R+1] , str(self.chiToNum(addrCom[L+1:R+1])) )
        return addrCom

    def offsetAddrXY( self ):  #篩選門牌->偏移坐標
        layer = iface.activeLayer()
        layer.startEditing()
        addrAttrName = ''
        for val in layer.fields().names():
            if( '門牌' in val):
                addrAttrName = val
        if(addrAttrName == ''):
            return
        #目前選取圖徵之id
        selNowId = layer.selectedFeatureIds() 
        # #目前選取圖徵
        # selNow = layer.selectedFeatures()    

        #進度條
        progressMessageBar = iface.messageBar().createMessage("作業中...")
        progress = QProgressBar()
        progress.setMaximum(self.spb_addrNum.value()) 
        progressMessageBar.layout().addWidget(progress)
        iface.messageBar().pushWidget(progressMessageBar, 1)
        iface.mainWindow().repaint()

        self.__fidList.clear()
        self.lab_pileCount.setText('-/-')
        pileCount = 1
        for i in range(1, self.spb_addrNum.value()+1):
            if i == 1:
                self.__fidList.append(selNowId)
            #表達式:
            exp = '\"'+addrAttrName+'\"LIKE\''+self.str_front.text()+ self.numToChi(i)+self.str_behind.text()+'\'OR\"'+addrAttrName+'\"LIKE\''+self.str_front.text()+ self.numToFull(i)+self.str_behind.text()+'\''
            #以id選取最初選擇圖徵 與 表達式選取圖徵交集
            layer.select(selNowId)
            layer.selectByExpression( exp , QgsVectorLayer.IntersectSelection )
            selInter = layer.selectedFeatures()
            selInterId = layer.selectedFeatureIds() 
            if selInter:    #若交集不為空
                self.__fidList.append(selInterId) #記住id
                pileCount+=1
                #逐一偏移被選取圖徵坐標
                for f in selInter: 
                    self.__fidList[0].remove(f.id())
                    geo = f.geometry()
                    geo.get().setX(geo.get().x() + i*2 - i//10*20) 
                    geo.get().setY(geo.get().y() + i//10*2) 
                    f.setGeometry(geo)  
                    layer.updateFeature(f)
            #進度條++
            progress.setValue(i)
        # print(self.__fidList)
        layer.removeSelection()
        if self.__fidList[0]!=[]:
            layer.select(self.__fidList[0])
            self.lab_pileCount.setText('1/'+str(pileCount))
        iface.messageBar().clearWidgets()
        iface.mapCanvas().refresh()

    def offsetFloorXY( self ):  #同一樓層偏移到不同坐標
        layer = iface.activeLayer()
        layer.startEditing()
        addrAttrName = ''
        floorAttrName = ''
        for val in layer.fields().names():
            if( '門牌' in val):
                addrAttrName = val
            if( '層次' in val) :
                floorAttrName = val
        if(addrAttrName == '' or floorAttrName == ''):
            return
        # 目前選取之圖徵
        selNow = layer.selectedFeatures()
        
        selNow.sort(key=lambda item: item[addrAttrName])

        #進度條
        progressMessageBar = iface.messageBar().createMessage("作業中...")
        progress = QProgressBar()
        progress.setMaximum(layer.selectedFeatureCount()) 
        progressMessageBar.layout().addWidget(progress)
        iface.messageBar().pushWidget(progressMessageBar, 1)
        iface.mainWindow().repaint()
        idxProgress = 0

        self.__fidList.clear()
        self.lab_pileCount.setText('-/-')
        idxList = -1 #目前1維List可存取位置
        floorDict = {}
        for f in selNow:
            geo = f.geometry()
            Floor = f[floorAttrName]
            #若已存在相同層次，偏移坐標+1，不存在則存入字典後偏移
            if floorDict.__contains__( Floor ):
                floorDict.update({Floor : floorDict[Floor]+1})
                if idxList < floorDict[ Floor ]: #記住id
                    self.__fidList.append([f.id()])
                    idxList+=1
                else: 
                    self.__fidList[ floorDict[ Floor ] ].append(f.id())  
                geo.get().setX(geo.get().x() + floorDict[ Floor ]*2 - floorDict[ Floor ]//10*20) 
                geo.get().setY(geo.get().y() + floorDict[ Floor ]//10*2) 
                f.setGeometry(geo)  
                layer.updateFeature(f)
            else:
                floorDict.setdefault(Floor, 0 )
                if idxList < floorDict[ Floor ]: #記住id
                    self.__fidList.append([f.id()])
                    idxList+=1
                else: 
                    self.__fidList[0].append(f.id())  
                geo.get().setX(geo.get().x() + floorDict[ Floor ]*2 - floorDict[ Floor ]//10*20) 
                geo.get().setY(geo.get().y() + floorDict[ Floor ]//10*2) 
                f.setGeometry(geo)  
                layer.updateFeature(f)
            #進度條++
            idxProgress+=1
            progress.setValue(idxProgress)
        layer.removeSelection()
        if self.__fidList:
            layer.select(self.__fidList[0])
            self.lab_pileCount.setText('1/'+str(idxList+1))
        iface.messageBar().clearWidgets()
        iface.mapCanvas().refresh()

    def offsetAuto(self):  #去除門牌字串'X樓'&將'之''號'相關數字轉為數字，去除號後比對偏移坐標
        layer = iface.activeLayer()
        layer.startEditing()
        addrAttrName = ''
        for val in layer.fields().names():
            if( '門牌' in val):
                addrAttrName = val
        if(addrAttrName == ''):
            return
        # 目前選取圖徵之id
        # selNowId = layer.selectedFeatureIds() 
        # 目前選取之圖徵
        selNow = layer.selectedFeatures()
        selNow.sort(key=lambda item: item[addrAttrName])

        #進度條
        progressMessageBar = iface.messageBar().createMessage("作業中...")
        progress = QProgressBar()
        progress.setMaximum(layer.selectedFeatureCount()) 
        progressMessageBar.layout().addWidget(progress)
        iface.messageBar().pushWidget(progressMessageBar, 1)
        iface.mainWindow().repaint()
        idxProgress = 0
        self.__fidList.clear()

        addrDict = {}
        self.lab_pileCount.setText('-/-')
        idxDict = 0
        for f in selNow:
            geo = f.geometry()
            addrCom = self.addrDeal( f[addrAttrName] )
            #若已存在相同門牌點，偏移相同坐標，不存在則存入字典後偏移  
            if addrDict.__contains__( addrCom ):
                self.__fidList[ addrDict[ addrCom ] ].append(f.id()) #記住id
                geo.get().setX(geo.get().x() + addrDict[ addrCom ]*2 - addrDict[ addrCom ]//10*20) 
                geo.get().setY(geo.get().y() + addrDict[ addrCom ]//10*2) 
                f.setGeometry(geo)  
                layer.updateFeature(f)
            else:
                self.__fidList.append([f.id()]) #記住id
                addrDict.setdefault(addrCom, idxDict )
                geo.get().setX(geo.get().x() + addrDict[ addrCom ]*2 - addrDict[ addrCom ]//10*20) 
                geo.get().setY(geo.get().y() + addrDict[ addrCom ]//10*2) 
                f.setGeometry(geo)  
                layer.updateFeature(f)
                idxDict+=1
            #進度條++
            idxProgress+=1   
            progress.setValue(idxProgress)
        layer.removeSelection()
        if self.__fidList:
            layer.select(self.__fidList[0])
            self.lab_pileCount.setText('1/'+str(idxDict))
        iface.messageBar().clearWidgets()
        iface.mapCanvas().refresh()

    def pileNext(self): #選取下一堆圖徵
        if self.__fidList:
            pileStr = self.lab_pileCount.text().split('/')
            pileAll = int( pileStr[1])
            pileNum  = int( pileStr[0] )
            if pileNum == pileAll:
                pileNum=1
                self.lab_pileCount.setText('1/'+pileStr[1])
            else:
                pileNum+=1
                self.lab_pileCount.setText(str(pileNum)+'/'+pileStr[1])
            self.pileSelect(pileNum)

    def pilePre(self): #選取前一堆圖徵
        if self.__fidList:
            pileStr = self.lab_pileCount.text().split('/')
            pileAll = int( pileStr[1])
            pileNum  = int( pileStr[0] )
            if pileNum == 1:
                pileNum=pileAll
                self.lab_pileCount.setText(pileStr[1]+'/'+pileStr[1])
            else:
                pileNum-=1
                self.lab_pileCount.setText(str(pileNum)+'/'+pileStr[1])
            self.pileSelect(pileNum)

    def pileSelect(self, pileNum): #選取堆數數字圖徵
        layer = iface.activeLayer()
        layer.removeSelection()
        layer.select(self.__fidList[pileNum-1])

    def mergeOne(self): #已選取圖徵全部移動到已選取第一點之坐標
        layer = iface.activeLayer()
        layer.startEditing()
        #目前選取圖徵
        selNow = layer.selectedFeatures()    
        #目前有選到，則偏移被選取圖徵到第1個圖徵坐標
        if selNow:
            x = selNow[0].geometry().get().x()
            y = selNow[0].geometry().get().y()
            for f in selNow: 
                geo = f.geometry()
                geo.get().setX(x)
                geo.get().setY(y)
                f.setGeometry(geo) 
                layer.updateFeature(f)
        iface.mapCanvas().refresh()

    def displayPoint( self, pointTool ): #依滑鼠點擊坐標移動選取圖徵
        # print ('({:.4f}, {:.4f})'.format(pointTool[0], pointTool[1]))
        layer = iface.activeLayer()
        layer.startEditing()
        #目前選取圖徵
        selNow = layer.selectedFeatures()
        #目前有選到，則平移第1個圖徵與點選坐標之差
        if selNow:  
            dx = pointTool[0] - selNow[0].geometry().get().x()
            dy = pointTool[1] - selNow[0].geometry().get().y()
            for f in selNow: 
                geo = f.geometry()
                geo.get().setX(geo.get().x() + dx) #偏移被選取圖徵
                geo.get().setY(geo.get().y() + dy) #偏移被選取圖徵
                f.setGeometry(geo)  #更新偏移坐標
                layer.updateFeature(f)
        if self.check_autoNext.isChecked():
            self.pileNext()
        iface.mapCanvas().refresh()
        # iface.actionPan().trigger()
        
    def moveFeatures(self): #根據滑鼠點擊位置事件呼叫display_point
        # a reference to our map canvas 
        self.canvas = iface.mapCanvas() 
        # this QGIS tool emits as QgsPoint after each click on the map canvas
        self.pointTool = QgsMapToolEmitPoint(self.canvas)
        self.pointTool.canvasClicked.connect( self.displayPoint )  
        self.canvas.setMapTool( self.pointTool )

    def changeText(self):  #預覽搜尋條件同步更新文字
        self.lab_preview.setText( '"建物門牌"LIKE\''+self.str_front.text() +'{數字1-'+f'{self.spb_addrNum.text()}'+'}' + self.str_behind.text() +'\'' )
    
